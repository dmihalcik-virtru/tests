import tokenRequester from 'keycloak-request-token';
import {expect, test} from "@playwright/test";
import {constants} from "http2";
import * as fs from "fs";
import * as readline from "readline";

// @ts-ignore
const {authority, attributes, clientId, realm} = JSON.parse(process.env.SERVER_DATA);
const {grantor} = JSON.parse(process.env.TEST_DATA);

const baseUrl = authority.substring(0, authority.length - 1);
const settings = {
    username: grantor.username,
    password: grantor.password,
    grant_type: 'password',
    client_id: clientId,
    realmName: realm
};

// Request context is reused by all tests in the file.
let apiContext;
// test data
let genericSqlInjectionPayload: [string];


test.beforeAll(async ({playwright}) => {
    // read test data
    const rl = readline.createInterface({
        input: fs.createReadStream('resources/generic-sql-injection-payload.txt'),
        output: process.stdout,
        terminal: false
    });
    rl.on('line', (line) => {
        if (line.trim()) {
            if (!genericSqlInjectionPayload) {
                genericSqlInjectionPayload = [line.trim()];
            }
            genericSqlInjectionPayload.push(line.trim());
        }
    });
    // login
    const token = await tokenRequester(baseUrl, settings);
    apiContext = await playwright.request.newContext({
        extraHTTPHeaders: {
            'Authorization': `Bearer ${token}`,
        },
    });
})

test.afterAll(async ({}) => {
    // Dispose all responses.
    await apiContext.dispose();
});

test('attributes header test', async ({request}) => {
    const response = await apiContext.get(`${attributes}/attributes`, {});
    expect(response.status()).toBe(constants.HTTP_STATUS_OK);
    const headers = response.headers();
    // console.log(headers);
    expect(headers['x-content-type-options']).toBeTruthy();
    await expect(headers['x-content-type-options']).toContain('nosniff');
    expect(headers['content-security-policy']).toBeTruthy();
    await expect(headers['content-security-policy']).toContain('nosniff');
});

test('attributes authority test', async ({request}) => {
    const testAuthority = {
        "authority": `https://test.dev`,
    };
    const response = await apiContext.post(`${attributes}/authorities`, {
        data: testAuthority
    });
    expect(response.status()).not.toBe(constants.HTTP_STATUS_INTERNAL_SERVER_ERROR);
    console.log(response.status());
    console.log((await response.body()).toString());
});

test('attributes authority sql injection test', async ({request}) => {
    for (let payload of genericSqlInjectionPayload) {
        const testAuthority = {
            "authority": `https://${payload}`,
        };
        const response = await apiContext.post(`${attributes}/authorities`, {
            data: testAuthority
        });
        expect(response.status()).not.toBe(constants.HTTP_STATUS_INTERNAL_SERVER_ERROR);
        console.log(response.status());
        console.log((await response.body()).toString());
    }
});

test('attributes definition test', async ({request}) => {
    const response = await apiContext.get(`${attributes}/definitions/attributes`);
    expect(response.status()).not.toBe(constants.HTTP_STATUS_INTERNAL_SERVER_ERROR);
    console.log(response.status());
    console.log((await response.body()).toString());
});

test('attributes definition sql injection test', async ({request}) => {
    for (let payload of genericSqlInjectionPayload) {
        const testAttributeDefinition = {
            "authority": `https://${payload}`,
            "name": payload,
            "state": payload,
            "rule": "hierarchy",
            "order": [
                payload
            ]
        };
        const response = await apiContext.post(`${attributes}/definitions/attributes`, {
            data: testAttributeDefinition
        });
        expect(response.status()).not.toBe(constants.HTTP_STATUS_INTERNAL_SERVER_ERROR);
        console.log(response.status());
        console.log((await response.body()).toString());
    }
});

test('attributes definition name order sql injection test', async ({request}) => {
    for (let payload of genericSqlInjectionPayload) {
        const testAttributeDefinition = {
            "authority": `https://test.dev`,
            "name": payload,
            "state": payload,
            "rule": "hierarchy",
            "order": [
                payload
            ]
        };
        const response = await apiContext.post(`${attributes}/definitions/attributes`, {
            data: testAttributeDefinition
        });
        expect(response.status()).not.toBe(constants.HTTP_STATUS_INTERNAL_SERVER_ERROR);
        console.log(response.status());
        console.log((await response.body()).toString());
    }
});

test('attributes attribute value sql injection test', async ({request}) => {
    let testEntityId = 'aa3fa152-b574-4869-9086-d5f97bd1ad97'; // test-entity-nonperson-00
    const testEntitlements = [`https://a/attr/a/value/a`];
    for (let payload of genericSqlInjectionPayload) {
        testEntitlements.push(`https://a/attr/a/value/${payload}`);
    }
    const response = await apiContext.post(`${attributes}/attributes/${testEntityId}`, {
        data: testEntitlements
    });
    expect(response.status()).not.toBe(constants.HTTP_STATUS_INTERNAL_SERVER_ERROR);
    console.log(response.status());
    console.log((await response.body()).toString());
});

test('attributes attribute name sql injection test', async ({request}) => {
    let testEntityId = 'aa3fa152-b574-4869-9086-d5f97bd1ad97'; // test-entity-nonperson-00
    const testEntitlements = [`https://a/attr/a/value/a`];
    for (let payload of genericSqlInjectionPayload) {
        testEntitlements.push(`https://a/attr/${payload}/value/a`);
    }
    const response = await apiContext.post(`${attributes}/attributes/${testEntityId}`, {
        data: testEntitlements
    });
    expect(response.status()).not.toBe(constants.HTTP_STATUS_INTERNAL_SERVER_ERROR);
    console.log(response.status());
    console.log((await response.body()).toString());
});

test('attributes attribute authority sql injection test', async ({request}) => {
    let testEntityId = 'aa3fa152-b574-4869-9086-d5f97bd1ad97'; // test-entity-nonperson-00
    const testEntitlements = [`https://a/attr/a/value/a`];
    for (let payload of genericSqlInjectionPayload) {
        testEntitlements.push(`https://${payload}/attr/a/value/a`);
    }
    const response = await apiContext.post(`${attributes}/attributes/${testEntityId}`, {
        data: testEntitlements
    });
    expect(response.status()).not.toBe(constants.HTTP_STATUS_INTERNAL_SERVER_ERROR);
    console.log(response.status());
    console.log((await response.body()).toString());
});

test('attributes entityId sql injection test', async ({request}) => {
    const testEntitlements = [`https://a/attr/a/value/a`];
    for (let payload of genericSqlInjectionPayload) {
        const encodedPayload = encodeURIComponent(payload);
        const response = await apiContext.post(`${attributes}/attributes/${encodedPayload}`, {
            data: testEntitlements
        });
        expect(response.status()).not.toBe(constants.HTTP_STATUS_INTERNAL_SERVER_ERROR);
        console.log(response.status());
        console.log((await response.body()).toString());
    }
});

test('attributes query authority sql injection test', async ({request}) => {
    for (let payload of genericSqlInjectionPayload) {
        const encodedPayload = encodeURIComponent('https://' + payload);
        const response = await apiContext.get(`${attributes}/attributes?authority=${encodedPayload}`);
        expect(response.status()).not.toBe(constants.HTTP_STATUS_INTERNAL_SERVER_ERROR);
        console.log(response.status());
        console.log((await response.body()).toString());
    }
});

test('attributes query entityId sql injection test', async ({request}) => {
    for (let payload of genericSqlInjectionPayload) {
        const encodedQuery = encodeURIComponent(payload);
        const response = await apiContext.get(`${attributes}/attributes?entityId=${encodedQuery}`);
        expect(response.status()).not.toBe(constants.HTTP_STATUS_INTERNAL_SERVER_ERROR);
        console.log(response.status());
        console.log((await response.body()).toString());
    }
});

test('attributes query pagination sql injection test', async ({request}) => {
    for (let payload of genericSqlInjectionPayload) {
        const encodedQuery = encodeURIComponent(payload);
        const response = await apiContext.get(`${attributes}/attributes?sort=${encodedQuery}&offset=${encodedQuery}&limit=${encodedQuery}`);
        expect(response.status()).not.toBe(constants.HTTP_STATUS_INTERNAL_SERVER_ERROR);
        console.log(response.status());
        console.log((await response.body()).toString());
    }
});

test('attributes query rest sql injection test', async ({request}) => {
    for (let payload of genericSqlInjectionPayload) {
        const encodedQuery = encodeURIComponent(payload);
        const response = await apiContext.get(`${attributes}/attributes?name=${encodedQuery}&value=${encodedQuery}`);
        expect(response.status()).not.toBe(constants.HTTP_STATUS_INTERNAL_SERVER_ERROR);
        console.log(response.status());
        console.log((await response.body()).toString());
    }
});
